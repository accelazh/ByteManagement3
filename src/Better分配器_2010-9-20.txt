1. 空间分配器非得要有两层才好。下层分配器，支持分配的空间大小很广（1Byte~1000G...），
但是代价是浪费空间。BinaryBytePool是个下层分配器，操作系统的文件系统也是，1簇就是4K。
要是分配1000个文件，每个只写1Byte，就是1000个4K了。上层分配器，可以只专精与一种大小
的块的分配，仅浪费很少的空间。下层分配器向上层分配器提供了，一个虚拟的可以扩张/收缩的
连续空间，其实就是和文件一样。

2. 我最早设计和实现的分配器，使用的是定长的链接块作为分配的基本单元。这个思路很有用，
只是当时的实现太烂了，所以效率低下。现在重新考虑，优点多多：
	1. 这个BytePool使用定常的块作为分配单元，块的头部放一指针，链接到下一块。大于一块的
	空间，可以用多个块链接到一起构成。
	2. 因为块等长，所以支持对分配的空间的随机访问
	3. 分配所浪费的空间，最多为一个单元块的大小。
	3.5. 块大些，可以减少读写被不连续的块打断的
	开销，但是空间浪费大。块小些，浪费的空间少，但是因块不连续所造成的读写分散开销会变大。
	4. 自由块的分配和是否，由链接块构成的链表来做。为了支持并发，可以多设计条链表（都是
	同一个长度的块的）。
	5. 当需要分配有多个块链接而成的空间时，因为在链表中和分配后，块本来就是连接好的，因此
	分配时都不需要重写链接指针，整取整放，非常便利。
	6. 因为没有块合并、拆分，设计非常简单，并发支持非常简单，效率也高。
	7. 缺陷：如果块大小设置得比较大，比如1M，那么分配小空间，比如16Byte，就会超级浪费空间，
	当分配很多时，会浪费空间致死。使用两级分配器架构，就可以解决这个问题。
	8. 相比BinaryBytePool，简单了相当相当多
	9. 块的链接指针，可以使用长整型，因为必为非负数，因此最大位可以腾出来，用于标记块是否已
	经分配。
	10. 一个很棒的特性，当一分配的空间需要扩张或者缩减时，非常容易，而且不需要复制数据，还
	可以链接块整存整取。

3. 使用定长链接块的分配器，制作上下两层（上层叫第二级，下层叫第一级）分配器。你会发现
 定长链接块的分配器做上层、做下层都合适。
	1. 下层：使用一个块大小很大的定长链接块分配器，比如1M。这个分配器提供，从0到2^64的
	空间分配。使用大块，以保证磁盘读写尽量少地被不连续的块打断，浪费空间的问题，由上层
	分配器解决。
	2. 上层：由一系列块大小是16Byte的倍数的定长块分配器组成。这些分配器使用同一个下层
	分配器各自获得供自己管理的空间，如果下层分配器是操作系统的文件系统，那么上层的各个
	分配器就是分别给自己每人一个文件。块大小为N的分配器，只需要能够分配大小为N的空间就
	可以了，实际上这只是使用了定长链接块分配器的一部分功能。当需要分配大小为S的空间时，
	先将S向上并到16Byte的倍数，然后交由块大小为此的那个分配器去分配就好了。
	3. 下层分配器对于上层分配器来说，实际上是给每个分配器提供了一个文件。上层分配器释放
	空间时，合适的时候，也会缩减这个文件大小，实际上就把空间还给了下层分配器。这个空间经
	由下层分配器，可以被其它的上层分配器利用。这样就实现了合并并再利用小空间非配所产生的
	碎片这个功能。
	4. 上层分配器，由于专精化地管理各种不同大小的空间分配，因此分配小空间导致浪费的问题
	也解决了。
	5. 缺点：相对BinaryBytePool，上述分配器在重新利用空间时，并没有这个单层的分配器那么及时，毕
	竟需要上层分配器缩减文件大小后，下层分配器才能利用。而上层分配器中可能还存在着一些可以合
	并成大块的空间。目前看来，这个缺点并不太成问题。
	6. 很重要的一点，上层的分配器会很多，因此需要懒惰创建，否则太费资源了。
	7. 图示见对应名字的ppt。
	9. 又是很重要的一点，对于上层分配器，如果需要分配一个超过下层分配器块大小的空间，那么
	不需要多做任何事，直接呼叫下层即可。这样在空间回收上也好些。
	10. 因为定长链接块分配的性质，SegmentArray的存在就不必要了，各种大小的空间分配，
	释放后，都可以被打散成单元块，互相重新利用。
	
